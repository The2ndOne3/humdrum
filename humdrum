#!/usr/bin/env node

var child = require('child_process')
  , spawn = child.spawn
  , exec = child.exec;

// CLI setup.
var program = require('commander')
  .version(require('./package').version)
  .usage('<command> [options] [nodemon-options]')
  .description('Continuously run a script against an expected output file.')
  .option('-o, --output <file>', 'expected output file')
  .option('--nodemon-help', 'show nodemon help')
  .option('--nodemon-version', 'show nodemon version');

if(program.nodemonHelp){
  return exec('node node_modules/nodemon/ --help', function(err, stdout){
    if(err){
      console.error(err);
    }
    return process.stdout.write(stdout.toString());
  });
}

if(program.nodemonVersion){
  return exec('node node_modules/nodemon/ --version', function(err, stdout){
    if(err){
      console.error(err);
    }
    return process.stdout.write(stdout.toString());
  });
}

// Do nothing with unknown options -- capture for nodemon.
program.unknownOption = function(){};

// See hack @ https://github.com/nitoyon/livereloadx/commit/521581279a1f1d840685d49729d6d0cf3a64d1b
program._name = 'salviati';
var parsed = program.parseOptions(program.normalize(process.argv.slice(2)));
program.args = parsed.args;
if (parsed.unknown.length > 0) {
  program.parseArgs([], parsed.unknown);
}
var monitor_flags = parsed.unknown;

if(program.args.length < 1){
  var missing_args = ['<command>'].slice(program.args.length);
  return console.error(
    '\n' +
    'error: ' + missing_args.join(', ') +
    ' argument' + (missing_args.length > 1 ? 's' : '') + ' missing' +
    '\n'
  );
}

if(!program.output){
  return console.error(
    '\n' +
    'error: -o, --output <file> mandatory argument missing' +
    '\n'
  );
}

// Monitor setup.
var monitor = spawn('/usr/bin/env',
  ['node', 'node_modules/nodemon']
    .concat(monitor_flags)
    .concat(['--exec'])
    .concat(program.args),
  {
    stdio: [0, 'pipe', 2]
});

monitor.on('error', function(err){
  console.error('Error:', err);
  process.exit(1);
});
monitor.on('exit', function(code){
  console.log('Exited with code', code);
  process.exit(0);
});

process.on('exit', function(){
  monitor.kill();
});

// Diffing setup.
var diff = require('diff')
  , chardet = require('jschardet')
  , fs = require('fs')
  , path = require('path');

try{
  var expected = fs.readFileSync(path.join(__dirname, program.output));
  expected = expected.toString(chardet.detect(expected).encoding);
}
catch(err){
  if(err.code == 'ENOENT'){
    console.error('Output file does not exist.');
  }
  console.error(err);
  process.exit(1);
}

var check_output = function(output, expected){
  var difference = diff.diffLines(expected.trim(), output.trim());
  var correctness = difference.filter(function(element){
    return 'added' in element || 'removed' in element;
  }).length === 0;

  var patch = diff.createPatch('output', expected, output, 'expected', 'actual');

  return {
    correct: correctness,
    diff: patch
  };
};

var current_output = '';
monitor.stdout.on('readable', function(){
  var chunk = monitor.stdout.read().toString();
  if(chunk.indexOf('[nodemon]') == -1){
    current_output += chunk;
  }
  else if(chunk.indexOf('clean exit') > -1){
    console.log();
    var check = check_output(current_output, expected);
    if(check.correct){
      console.log('Test passed!');
    }
    else{
      console.log('Test failed:');
      console.log(check.diff);
    }
    console.log('Waiting for changes...');
    current_output = '';
  }
  else if(chunk.indexOf('app crashed') > -1){
    console.log();
    current_output = '';
    console.log('Test failed -- build crashed.');
  }
});